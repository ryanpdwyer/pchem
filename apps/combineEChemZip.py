
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
import streamlit as st
import zipfile
import glob
import io
import base64
from scipy import signal
from util import process_file


def set_x_limit(ax):
    if ax:
        x_min_val, x_max_val = ax.get_xlim()
        x_min = st.number_input("Choose minimum x:", value=x_min_val)
        x_max = st.number_input("Choose maximum x:", value=x_max_val)
        ax.set_xlim(x_min, x_max)

def set_y_limit(ax):
    if ax:
        y_min_val, y_max_val = ax.get_ylim()
        y_min = st.number_input("Choose minimum y:", value=y_min_val)
        y_max = st.number_input("Choose maximum y:", value=y_max_val)
        ax.set_ylim(y_min, y_max)

def limit_cycles(data, settings):
    max_val = 1
    if all('Segment' in df for df in data):
        st.markdown("## Limit Segments")
        max_val = max([max(df['Segment'].values) for df in data])
        st.write(max_val)
    else:
        return data, settings

    segment_min, segment_max = st.slider("Included Segments:", min_value=1, max_value=int(max_val), value=[1, int(max_val)], step=1)

    settings['segment_min'] = segment_min
    settings['segment_max'] = segment_max

    data_out = []
    for df in data:
        mask = (df['Segment'].values >= segment_min) * (df['Segment'].values <= segment_max)
        data_out.append(df[mask])
    
    return data_out, settings

def derivative(data, y_column, x_column, settings):

    st.markdown("""### Peak picking settings
The peak smoothing parameter can be adjusted to minimize false positives and help the peak picking algorithm find a single peak.
    """)
    dV_peak = st.number_input("Peak smoothing (x-axis units)", value=0.05)
    settings['dV_peak'] = dV_peak


    for df in data:
        dV = np.mean(np.abs(np.gradient(df[x_column].values)))
        window = signal.get_window('triang', np.round(dV_peak/dV).astype(int))
        y = df[y_column].values
        dy = signal.convolve(np.gradient(y/abs(y).max()),window, mode='same')
        df['dy'] = dy

        # Zero crossings
        inds = np.where(np.diff(np.sign(dy)))[0]
        peaks = np.zeros_like(y, dtype=bool)
        peaks[inds] = True
        df["Peak"] = peaks

    

    return data, settings

def limit_x_values(data, x_column, settings):
    st.markdown("### Limit x Range")
    x_min = st.number_input("Choose minimum x:", value=min([min(df[x_column].values) for df in data]))
    x_max = st.number_input("Choose maximum x:", value=max([max(df[x_column].values) for df in data]))
    settings['x_min'] = x_min
    settings['x_max'] = x_max
    data_out = []
    for df in data:
        mask = (df[x_column].values > x_min) * (df[x_column].values < x_max)
        data_out.append(df[mask])
    return data_out, settings

scales = {'A': 1, 'mA': 1e3, 'ÂµA': 1e6, 'nA': 1e9}

def scale_current(data, y_column, settings):
    st.markdown("### Scale Current")
    scale = st.selectbox("Scale:", list(scales.keys()), index=1)
    settings['y_scale'] = scale
    data_out = []
    for df in data:
        df2 = df.copy()
        df2[y_column] = df2[y_column] * scales[scale]
        data_out.append(df2)
    return data_out, settings



def shift_x_axis(data, x_column, settings):
    st.markdown("""### Re-align x Axis
This allows the potential axis to be shifted (based on a peak in an internal standard such as ferrocene, for example).
""")
    offset = st.number_input("New versus", value=0.0)
    settings['x_offset'] = offset
    data_out = []
    for df in data:
        df2 = df.copy()
        df2[x_column] = df2[x_column] - settings['x_offset']
        data_out.append(df2)
    return data_out, settings


def run():
    df = None
    cols = None
    x_column = y_column = None
    combined_data = None
    processing="None"
    if 'ever_submitted' not in st.session_state:
        st.session_state.ever_submitted = False
    settings = {"processing": "None"}
    st.markdown("""## Combine CSV Electrochemistry files

This helper will combine multiple CSV files (or Excel spreadsheets)
for easy plotting; it is designed to work with the structured CSV files generated by
[AfterMath](https://pineresearch.com/shop/kb/knowledge-category/aftermath-user-guide/).

    """)

    files = st.file_uploader("Upload CSV or excel files",
                accept_multiple_files=True)

    st.markdown("### Zip file upload")
    zip_file_upload = st.file_uploader("Upload Zip file of Aftermath exports",
                accept_multiple_files=False)

    if zip_file_upload is not None:
        st.write("Processing zip file...")
        zip_file = zipfile.ZipFile(zip_file_upload)
        zip_filenames = zip_file.namelist()
        zip_experiment_folders = np.array([x for x in zip_filenames if 'Experiment' in x and x.endswith('/')])
        zip_experiment_folder_depths = np.array([x.count('/') for x in zip_experiment_folders])
        expt_depth = zip_experiment_folder_depths.min()
        zip_experiment_folder_names = zip_experiment_folders[zip_experiment_folder_depths == expt_depth]

        zip_experiment_folder_prefix = [x.split('/')[0] for x in zip_experiment_folder_names]
        zip_experiment_folder_prefix = np.unique(zip_experiment_folder_prefix)
        for prefix in zip_experiment_folder_prefix:
            st.write(f"Archive: {prefix}")
            folder_names_without_prefix = [x.replace(prefix+'/', '') for x in zip_experiment_folder_names]
            st.write(folder_names_without_prefix)
                



    if files:
        st.write(files)

        filenames = [(i, f.name) for i, f in enumerate(files)]
        data = [process_file(f) for f in files]

        ind_fname = st.selectbox("Choose data to display: ", filenames,
            format_func=lambda x: x[1], index=0)

        st.write("""## Labels
Use the boxes below to change the labels for each line that will go on the graph.
        """)
        labels = [st.text_input(f"{filename[0]}. {filename[1]}", value=filename[1]) for filename in filenames]
        
        if ind_fname:
            df = data[ind_fname[0]]
            cols = list(df.columns)
    

        st.write("## Choose columns")
        with st.form("column_chooser_and_run"):
            x_column = st.selectbox("Choose the x column: ", cols)
            y_column = st.selectbox("Choose y column: ", cols, index=len(cols)-1)

            submitted = st.form_submit_button()

        st.session_state.ever_submitted = submitted | st.session_state.ever_submitted

        use_plotly = st.checkbox("Use plotly?", value=True)

        if data is not None:

            data, settings = limit_x_values(data, x_column, settings)
            data, settings = limit_cycles(data, settings)
            data, settings = scale_current(data, y_column, settings)
            data, settings = shift_x_axis(data, x_column, settings)
            data, settings = derivative(data, y_column, x_column, settings)
            

            # data, settings = normalize_data(data, x_column, settings)
            # x_data = combined_data[x_column].values
            # Plotting
            if use_plotly:
                fig = go.Figure()
            else:
                fig, ax = plt.subplots()
            for df, fname, label in zip(data, filenames, labels):
                peaks = df[df["Peak"] == True]
                if use_plotly:
                    fig.add_trace(go.Line(x=df[x_column], y=df[y_column], name=label))
                    fig.add_trace(go.Scatter(x=peaks[x_column], y=peaks[y_column], mode='markers', name=f"{label} peaks"))
                else:
                    ax.plot(df[x_column].values, df[y_column].values, label=label)
            


            y_label_default = f"{y_column} ({settings['y_scale']})"


            st.markdown("### Plotting options")    
            x_label = st.text_input("x-axis label: ", value=x_column)
            y_label = st.text_input('y-axis label: ', value=y_label_default)
            grid = st.checkbox("Grid?", value=False)

            if grid and not use_plotly:
                ax.grid()

            if use_plotly:
                fig.update_layout(xaxis_title=x_label, yaxis_title=y_label)
                st.plotly_chart(fig)
            else:
                ax.set_xlabel(x_label)
                ax.set_ylabel(y_label)
                set_x_limit(ax)
                set_y_limit(ax)
                ax.legend()
                st.pyplot(fig)
            
            st.write("### Derivative Information - Diagnostic only")
            fig3, ax3 = plt.subplots()

            for df, fname, label in zip(data, filenames, labels):
                ax3.plot(df[x_column], df['dy'], label=label)
                ax3.set_xlabel(x_label)
                ax3.set_ylabel('Deriv.' + y_label)
            
            st.pyplot(fig3)
            


            # # Saving
            # st.markdown("### Output options")
            # st.write(combined_data)
            # filename = st.text_input("Filename:", value="data")
            # write_excel(combined_data, filename)

if __name__ == "__main__":
    run()
